using System.Collections;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Text;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class LobbyManager_TCP : MonoBehaviour
{

    [SerializeField]
    string ipAddr = "127.0.0.1";
    [SerializeField]
    int port = 9999;


    TcpClient tcpClient;

    [SerializeField]
    GameObject content;

    Queue<string> msgQueue;

    [SerializeField]
    TMP_InputField roomText;

    [SerializeField]
    GameObject createRoomCanvas;

    [SerializeField]
    GameObject roomPrefab;

    [SerializeField]
    ScrollRect uiView;

    void Start()
    {
        msgQueue = new Queue<string>();

        ConnectTCP();


        // 방 목록 가져오는 코루틴 시작. 3초마다 갱신함. 
        StartCoroutine("GetRoomList");
    }


    void Update()
    {
        // SceneManager.LoadScene 작업은 메인 스레드에서만 해야 해서 들어온 데이터를 큐에 담아 메인 스레드에서 처리
        if (msgQueue.Count > 0)
        {
            var msg = msgQueue.Dequeue();

            Debug.Log("Received from Server : " + msg);

            if (msg.StartsWith("200"))
            {
                var textList = msg.Split(":");

                // 맨 마지막 문자열의 공백 제거 후 GameManager에 방 번호를 저장해준다. 
                GameObject.Find("GameManager").GetComponent<GameManager>().myRoomName = textList[1].TrimEnd('\0');
                SceneManager.LoadScene("ChatScene");
            }

            // 방 목록 처리
            if (msg.StartsWith("/list"))
            {
                var textList = msg.Split(":");
                var roomNameList = textList[1].Split(", ");

                SetRoomList(roomNameList);
            }
        }

    }

    // 약 3초에 한번 /list 명령어 보냄
    IEnumerator GetRoomList()
    {
        yield return new WaitForSecondsRealtime(1.5f);

        while (true)
        {
            if (tcpClient == null || !tcpClient.Connected) continue;

            var data = Encoding.UTF8.GetBytes("/list");
            tcpClient.GetStream().Write(data);

            yield return new WaitForSecondsRealtime(3.0f);
        }
    }


    //void SetRoomList(string[] roomNameList, string[] userCountList)
    void SetRoomList(string[] roomNameList)
    {
       for(int i = 0; i < roomNameList.Length; i++)
        {
            // 오브젝트 생성
            var newtextobj = Instantiate(roomPrefab, Vector3.zero, Quaternion.identity);
            string roomName = roomNameList[i];

            // 텍스트 넣기
            TMP_Text[] texts = newtextobj.GetComponentsInChildren<TMP_Text>();
            texts[0].text = roomName;

            // 버튼 리스너 달아줌
            Button enterBtn = newtextobj.GetComponentInChildren<Button>();
            enterBtn.onClick.AddListener(() =>
            {
                RoomEnterBtn(roomName);
            });


            // 뷰박스에 넣고 정보 갱신
            newtextobj.transform.SetParent(uiView.content, false);
            LayoutRebuilder.ForceRebuildLayoutImmediate(uiView.content);
        }
    }

    /// <summary>
    /// TCP client callback. TCP 연결 시도가 성공적으로 완료되었을 때 실행됨
    /// </summary>
    /// <param name="ar"></param>
    private void StartReadingTCP(System.IAsyncResult ar)
    {
        byte[] buf = new byte[512];


        // 나중에 본인 ID 받아와서 출력하게 바꾸기
        var data = Encoding.UTF8.GetBytes("Jiyee");
        tcpClient.GetStream().Write(data);



        // TCP 클라이언트의 네트워크 스트림에서 비동기적으로 데이터를 읽고,
        // 데이터를 읽은 후에는 OnTCPDataReceived 함수를 호출하여 데이터를 처리
        tcpClient.GetStream().BeginRead(buf, 0, buf.Length, OnTCPDataReceived, buf);
    }

    // 수신된 데이터가 처리되는 함수
    // TCP 통신에서 데이터를 수신할 때, 데이터를 처리하는 작업은 비동기적으로 이루어집니다.
    // 따라서 데이터가 도착하는 순서와 처리하는 순서가 일치하지 않을 수 있습니다.
    // 이를 관리하기 위해 데이터를 큐에 넣어 처리 대기열을 관리합니다.
    private void OnTCPDataReceived(System.IAsyncResult ar)
    {
        try
        {
            var byteRead = tcpClient.GetStream().EndRead(ar);

            if (byteRead > 0)
            {
                byte[] data = (byte[])ar.AsyncState;

                msgQueue.Enqueue(Encoding.UTF8.GetString(data));

                tcpClient.GetStream().BeginRead(data, 0, data.Length, OnTCPDataReceived, data);
            }
            else
            {
                // 연결이 끊어지면 프로그램 종료. 
                tcpClient.GetStream().Close();
                tcpClient.Close();
                tcpClient = null;

                Application.Quit();
            }
        }
        catch (SocketException e)
        {
            Debug.LogException(e);
            Application.Quit();
        }
    }

    // 테스트용 버튼 리스너, 추후 삭제하기
    public void TestBtn()
    {
        if (tcpClient == null || !tcpClient.Connected) return;

        //  서버에 전송하기 (GetStream().Write)
        var data = Encoding.UTF8.GetBytes("/join " + "hello_world");
        Debug.Log(data.ToString());
        tcpClient.GetStream().Write(data);
    }


    // 방 입장 버튼 리스너
    public void RoomEnterBtn(string btnName)
    {
        Debug.Log("Clicked Button: " + btnName);
        if (tcpClient == null || !tcpClient.Connected) return;

        //  서버에 전송하기 (GetStream().Write)
        var data = Encoding.UTF8.GetBytes("/join " + btnName);
        tcpClient.GetStream().Write(data);
    }

    // 로비 상단의 방 생성 버튼, 방제목 입력 Canvas 띄워줌. 수동으로 달아줌. 
    public void CreateBtnInLobby()
    {
        createRoomCanvas.SetActive(true);
    }

    // 방 생성 패널의 방 생성 버튼, 수동으로 달아줌. 
    public void CreateBtn()
    {
        if (tcpClient == null || !tcpClient.Connected) return;


        //  서버에 전송하기 (GetStream().Write)
        string roomName = roomText.text;
        Debug.Log("btn: create " + roomName);

        var data = Encoding.UTF8.GetBytes("/create " + roomName);
        tcpClient.GetStream().Write(data);

        // Canvas 닫음
        createRoomCanvas.SetActive(false);
    }

    // Canvas 닫는 버튼, 수동으로 달아줌. 
    public void CloseBtn()
    {
        createRoomCanvas.SetActive(false);
    }


    public void ConnectTCP()
    {
        tcpClient = new TcpClient();
        tcpClient.BeginConnect(ipAddr, port, StartReadingTCP, null);
    }


    private void OnDestroy()
    {
        // 방목록을 받아오고 세팅하는 코루틴들 종료
        StopAllCoroutines();

        if (tcpClient != null)
        {
            tcpClient.GetStream().Close();
            tcpClient.Close();
            tcpClient = null;
        }

    }
    
}
